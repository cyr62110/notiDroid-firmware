#include "../ndCore.h"

#include "ndEventBusCoreEventDispatcher.h"
#include "ndEventBusCoreConstants.h"

/**
 * TODO
 */
void dispatchHardwareEventToModule();

/**
 * 
 */
void dispatchHardwareEventToHandler();

/**
 * 
 */
void dispatchSoftwareEventToModule();

/**
 * 
 */
void dispatchSoftwareEventToHandler();

void dispatchEvent(eventCode_t eventCode) {
	/* If it is an empty event, we have nothing to do */
    if(!eventCode.internalStruct.isNotEmpty)
        return;
    /* Otherwise, we must load some register to send the eventcode to the event dispatcher ASM code. */
   PRODH = eventCode.internalStruct.moduleId;
   PRODL = eventCode.internalStruct.eventId;
    /* We call the modules block start address of the type of module we want */
    if(eventCode.internalStruct.type == EVENT_TYPE_HW) {
        dispatchHardwareEventToModule();
    } else {
        dispatchSoftwareEventToModule();
    }
}

void dispatchHardwareEventToModule() {
}

void dispatchHardwareEventToHandler() {
#asm
    MOVF (PRODL), 0, 0
    SUBLW 1
    BNZ $+6 ; We skip the next instruction
    GOTO 55Eh ;functionAddress ; We call the function registered to handle this event
#endasm
}

/**
 * Since these function is rewritten at runtime, they should be aligned on address that is a multipe of 32 bytes.
 * Because, we do not want to erase the first witten in ASM in the function, we will
 * align the return of this function instead of the start.
 *
 * So, lets make a little sum to find the size of this block of instruction :
 * 2 + 2 + 2 + 4 = 10 bytes.
 * We must place this function at a absolute address that can be written : 32X - 10
 * We know that the code for managing one module is 10 bytes long.
 * If we want to be able to manage N software module, we need 10N + 2 bytes (2 bytes for the return instruction).
 */
void dispatchSoftwareEventToModule() @ EVENTBUS_SOFTWARE_MODULE_DISPATCHER_ADDRESS {
    /* The first module is the eventbus, so everything is hardcoded and cannot be change */
    /* This code should be similar to the one that are generated when the user had his own modules */
    /* I wrote this code as an example of what must be generated by the function that will add module to the event dispatcher. */
    asm("MOVF PRODH, 0, 0"); //We copy the module id in the working register
    asm("SUBLW 0"); //We susbtract the module id to make an equality test
    asm("BNZ $+6"); //If not equals, we skip to the next module
    asm("GOTO _dispatchSoftwareEventToHandler"); //Otherwise we goto to the block that will branch to the event handler registered for this event
    //I use the name of the function since I am certain that the code at this address is the one that branch
    //to function that are registered as receiver of eventbus events.
}


/**
 * This function is also meant to be overwritten at runtime by adding more code to
 * branch to event receiving function.
 */
void dispatchSoftwareEventToHandler() @ EVENTBUS_SOFTWARE_EVENT_DISPATCHER_ADDRESS {
    /* Each block of code is thought to handle events of a given module. A block MUST always end with a RETURN instruction. */
    /* As for module, events of the eventbus are hardcoded and this block will be an example of what will be generated by the
     * function that will add event for a module in the event dispatcher. */
    asm("MOVF PRODL, 0, 0"); //We copy the event if in the working register
    asm("SUBLW 24h"); //We susbtract the event id to make an equality test : EVENT_EVENTBUS_REGISTER_HANDLERS
    asm("BNZ $+6"); //
    asm("GOTO _event_eventBus_registerHandlers"); //
}


